# dmr_C

The aim of the dmr_C project is to create a JIT compiler for C. Is is based on the the Linux [Sparse](https://sparse.wiki.kernel.org/index.php/Main_Page) library originally written by Linus Torvalds. 

The name dmr_C is a homage to Dennis M Ritchie.

## Overview

The code base is a fork of Sparse. The main changes are:

* Removal of global state (see issues log for outstanding issues)
* Ensure the library can be built on Windows using MSVC
* Modify the code to be more C++ friendly
* Convert the LLVM backend to a JIT compiler
* Add other backends - possibly based on nanojit and/or asmjit.

## Current status

* We are now able to build on Windows, Linux and Mac OSX. However there are platform specific limitations - see below for details.
* Global state has been removed except for the way ptr_list nodes are allocated.
* The LLVM backend has had many fixes and is able to compile real programs. See details below for what works and what doesn't.

## Build instructions

The build is pretty standard CMake build. There are no external dependencies except LLVM. To build without LLVM backend just try:

```
mkdir build
cd build
cmake ..
```
This will generate appropriate build files that can then be used to build the project.

To build with LLVM support, additional arguments are needed. Following instructions are for LLVM 3.9 on Windows 10. 

```
mkdir build
cd build
cmake -DLLVM_JIT=ON -DLLVM_DIR=$LLVM_INSTALL_DIR\lib\cmake\llvm -G "Visual Studio 15 2017 Win64" ..
```

Here $LLVM_INSTALL_DIR refers to the path where LLVM is installed. 

Build on Linux and Mac OSX is similar.

## Using dmr_C command line tools

The following command line tools are built:

* sparse-llvm - this tool takes in a source C file and generates an LLVM module. It writes the LLVM Module in LLVM bitcode format.
* linearize - this tool outputs the SSA IR generated by the parser and compiler front-end.
* showsymbols - this tool shows the global symbols found in a source file, output is generated in XML format.
* showparse - this tool displays the parse tree generated by the front-end. This is the parse tree that is fed to the linearizer to produce SSA IR.
* sparse - this is a tool for analysing C code 

### sparse-llvm tool

#### Limitations

* The main limitation is that complex initializers do not work - only strings and scalar variables can be initialized.
* There is no support for computed gotos, slices and ranges yet.
* The parser and pre-processor knows about many Linux constructs hence it can process C header files on Linux. However, it doesn't know about Windows or Mac OSX features. As typically the vendor supplied header files have many platform specific extensions, unfortunately this means that you cannot process vendor supplied header files on these platforms.

#### Usage

* The tool will output the preprocesed source code if -E option is given.
* The tool will save the output to specified file if -o option is given, otherwise output is saved to file named 'out.bc' in current directory.
* The -O1 option can be used to enable internal IR simplifications. Note that these simplifications sometimes cause issues - see the tests/bugs folder for known issues. 
* To run the generated module, you typically need to generate assembly code and then link it to produce an executable. Example:

```
sparse-llvm test.c -o test.bc
llc test.c
gcc -o test test.s

```

* Alternatively you can also run the bitcode directly using the LLVM command `lli`.

```
sparse-llvm test.c -o test.bc
lli test.bc

```

* You can generate LLVM IR by running the `llvm-dis` command.

```
sparse-llvm test.c -o test.bc
llvm-dis test.bc

```

#### Bugs

Many bugs have been fixed and the tool is able to compile and run real programs. However there are still bugs that mean that the generated code is sometimes not correct. See the `tests/bugs` folder for examples of programs that fail to compile successfully. If you hit a problem, please submit a bug report with a minimal example of program that fails.


## Using dmr_C as a library

The dmr_C is also a library and can be linked and used by application programs. As a library following features are available:

* Tokenizer
* Preprocesser
* Parser and Semantic analyser
* Linearizer
* LLVM backend

Details of each of these is given below.

## Tokenizer

Here is a simple program that uses the tokenizer. The tokenizer converts the input into a stream of tokens.

```
	struct dmr_C *C = new_dmr_C();

	char test1[100] =
	    "int main() { printf(\"hello world!\\n\"); return 0; }";
	struct token *start;
	struct token *end;
	start = tokenize_buffer(C, (unsigned char *)test1,
				(unsigned long)strlen(test1), &end);

	// do something with the tokens!
	for (struct token *p = start; p != end; p = p->next) {
		printf("%s\n", show_token(C, p));
	}

	destroy_dmr_C(C);
```

The state of the parser is maintained in a structure called dmr_C. All state is maintained here except for ptr_list nodes which are
managed globally due to the way the ptr_list is implemented (see issue #1).

The example above tokenizes a buffer, but it is also possible to tokenize a file.

The destroy_dmr_C() call cleans up the parser state except for the globally maintained ptr_list nodes.

## Preprocessor

The above example can be extended to use the preprocessor by just adding one line.

```
	start = tokenize_buffer(C, (unsigned char *)test1,
				(unsigned long)strlen(test1), &end);

	start = preprocess(C, start);
```

There is no driver as yet to pass various arguments but the underlying pre-processor can handle normal preprocessing of C programs.

## Parsing 

To follow.

## LLVM backend

To follow.

## Links

* [Sparse - a Semantic Parser for C](https://sparse.wiki.kernel.org/index.php/Main_Page)
* [Article on Sparse](https://lwn.net/Articles/689907/)
* [Wikipedia entry for Sparse](https://en.wikipedia.org/wiki/Sparse)
* [Sparse Linux Man Page](https://linux.die.net/man/1/sparse)
